#include <stdio.h>
#include <stdlib.h>
#include <allegro.h>
#define SCREEN_W 1184
#define SCREEN_H 800
#define NBRFD 2 //nombre de page de fond du debut du jeu (ceux du menu)
#define NBRBM 4 //nombre de page de bouton differents par menu
#define NBRINTER 3 //nombre de page de bouton differents par menu

//la structure du joueur
typedef struct joueur{
    int type;
    int x;
    int y;
    int pvPoint;
    int paPoint;
    BITMAP* tete;
    BITMAP* sort;
    BITMAP* immobile;
    BITMAP* avance[6];//N'EST PAS UTILISE ICI: y'aurait les sprites qui servent a la demarche/course du joueur
    BITMAP* attaque[6];//N'EST PAS UTILISE ICI: y'aurait les sprites qui servent a la premiere attaque du joueur
    BITMAP* attaque2[6];//N'EST PAS UTILISE ICI: y'aurait les sprites qui servent a la deuxieme attaque du joueur
}t_joueur;


void init_ALLEG(){
    allegro_init();
    set_color_depth(desktop_color_depth());

    if((set_gfx_mode(GFX_AUTODETECT_WINDOWED,SCREEN_W,SCREEN_H,0,0))!=0){
        allegro_message("Probleme de mode graphique !");
        allegro_exit();
        exit(EXIT_FAILURE);
    }
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   RECENTRER COORDONNEES   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    /*
        sert à recentrer le joueur pour que le personnage et les coordonnees du joueur soit
        au centre de la case et non a l'emplacement exacte de la souris à l'endroit ou la souris a cliqué
    */
void recentre(int* x, int* y){//coordonnees appuye par la souris
    //initialisation des cadres de multiples de 32
    int cadreB=0, cadreD=0;
    //cherche les multiples de 32 juste au-dessus des coordonnees
    while(cadreB<*x || cadreD<*y || cadreB<*x && cadreD<*y){
        if(cadreB<*x){
            cadreB=cadreB+32;
        }
        else if(cadreD<*y){
            cadreD=cadreD+32;
        }
        else if(cadreB<*x && cadreD<*y){
            cadreB=cadreB+32;
            cadreD=cadreD+32;
        }
    }
    /*/
        enleve moins 16 du multiple de 32 juste au-dessus du cadre pour
        avoir le centre de la case, et l'attribuer aux coordonnees
    /*/
    *x=(cadreB-16);
    *y=cadreD-16;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   CHRONO  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    /*
        Il n'est pas complétement abouti mais il aurait servi à chronometrer le temps entre l'appel du chrono et l'appui de la souris.
        Si la souris avait été cliqué avant ou après 30 secondes exactement alors il aurait envoyé une valeure booleenne de type -1 et 1 au programme appelant
        qui permettrait de faire en sorte que:
            - Si le chrono est à -1 alors le joueur à encore la possibilité de faire ce qu'il veut
            - Si le chrono est à 1 alors le programme choisirait un personnage ou changerait de tour, etc...
    */
/*/
int chrono(){
    long clk_tck = CLOCKS_PER_SEC;
   clock_t t1, t2;

   //Recuperation du temps initial en "clock ticks"
   t1 = clock();
   t2 = clock();
}
/*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   INITIALISATION DES BITMAPS DU JOUEUR    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    /*
        Integre les bitmaps de sprites correspondant au personnage choisi par le joueur.
        En fonction du type collecté en paramètre, le sous-programme d'initialisation pourra identifier quelles
        bitmaps il pour mettre dans la structure du joueur (donc en fonction du personnage choisi par le joueur).
        Ainsi, normalement si ça avait été fonctionnel il y'aurait une initialisation complète de toutes les variables du tableau de structure.
    */
/*/
void initialisation(int* type, int* caseTab, int* nbrJoueurs, t_joueur joueur[4]){
    int j=0;
    j=(* caseTab);
    char nomfichier[50]={0};

    if((* type)==1){
            /*//*/
        //images du perso dans bitmaps joueurs
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueG%d.bmp",nbrImage);//attack du guerrier
            joueur[j].attaque[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueG2%d.bmp",nbrImage);//attack2 du guerrier
            joueur[j].attaque2[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AvanceG%d.bmp",nbrImage);//avance du guerrier
            joueur[j].avance[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        /*//*/
    }
    else if((* type)==2){
            /*//*/
        //images du perso dans bitmaps joueurs
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueC%d.bmp",nbrImage);//attack du guerrier
            joueur[j].attaque[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueC2%d.bmp",nbrImage);//attack2 du guerrier
            joueur[j].attaque2[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AvanceC%d.bmp",nbrImage);//avance du guerrier
            joueur[j].avance[nbrImage]=load_bitmap(nomfichier,NULL);
        }
            /*//*/

    }
    else if((* type)==3){
            /*//*/
        //images du perso dans bitmaps joueurs
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueM%d.bmp",nbrImage);//attack du guerrier
            joueur[j].attaque[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueM2%d.bmp",nbrImage);//attack2 du guerrier
            joueur[j].attaque2[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AvanceM%d.bmp",nbrImage);//avance du guerrier
            joueur[j].avance[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        /*//*/
    }
    else if((* type)==4){
            /*//*/
        //images du perso dans bitmaps joueurs
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueS%d.bmp",nbrImage);//attack du guerrier
            joueur[j].attaque[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AttaqueS2%d.bmp",nbrImage);//attack2 du guerrier
            joueur[j].attaque2[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        for(int nbrImage=0; nbrImage<5; nbrImage++){//METTRE LA BONNE VALEURE DES NOMBRES D'IMAGES
            sprintf(nomfichier,"AvanceS%d.bmp",nbrImage);//avance du guerrier
            joueur[j].avance[nbrImage]=load_bitmap(nomfichier,NULL);
        }
        /*//*/

    }

}
/*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    MENU DE DEBUT   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    /*
        Sous-programme servant a afficher le menu et d'attribuer les personnages au joueurs.
        On passera a la page suivante une fois le bon endroit cliqué autant de fois requis
        (en fonction de notre page on aura des botuons differents affichés).
    */
int debut(t_joueur joueur[4], int* nbJ){

    //initialisation et declaration des variables et des bitmaps
    int j=0, page=1, nbrJoueurs=0, type=0, fin=0;//"fin" est notre booleen qui nous aidera à savoir si le programme est fini ou non
    int numFond=0,numBouton=0;//sert pour changer de boutons
    char nomfichier[50]={0};

    BITMAP* fond[2];//fond choisi
    BITMAP* bouton[5];//fond choisi
    BITMAP* buffy;//buffer

    //rempli les tableau de bitmaps
    for(numFond=0;numFond<NBRFD;numFond++){
        sprintf(nomfichier,"fond%d.bmp",numFond);
        fond[numFond]=load_bitmap(nomfichier,NULL);
    }
    for(numBouton=0;numBouton<NBRBM;numBouton++){
        sprintf(nomfichier,"page%d.bmp",numBouton);
        bouton[numBouton]=load_bitmap(nomfichier,NULL);
    }
    buffy=create_bitmap(SCREEN_W,SCREEN_H);

    //remise a 0 pour etape du menu
    numFond=0;
    numBouton=0;

    //installation du clavier et de la souris
    install_keyboard();
    install_mouse();
    show_mouse(screen);//affichage de la souris sur l'écran

    //////////////////
    //PROGRAMME MENU//
    //////////////////
    while(!key[KEY_ESC]){
        if(page==1){
                //1ERE: MENU
                /*
                    Bouton "START"
                */
           blit(fond[numFond],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
           masked_blit(bouton[numBouton],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
           blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
           if((mouse_b & 1) && mouse_x>470 && mouse_x<710 && mouse_y>427 && mouse_y<502){//si l'intervalle du bouton est cliqué alors on change de page et de bouton (=change completement l'interface)
                page++;
                numBouton++;
                numFond++;
           }
        }
        else if(page==2){
            //2EME: HISTOIRE JEU
            /*
                Mise en scene du jeu avec une histoire de presentation.
                Si on clique sur le bouton en bas, à gauche alors on pourra passer a la page suivante
            */
            blit(fond[numFond],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            masked_blit(bouton[numBouton],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
            rest(50);
            if((mouse_b & 1) && mouse_x>1084 && mouse_x<1108 && mouse_y>692 && mouse_y<728){
                page++;
                numBouton++;
            }
        }
        else if(page==3){
                //3EME: MENU JOUEURS
                /*
                    Page de selection du nombres de joueurs à séléctionner pour la partie.
                    Le nombre de joueurs est ainsi déterminé en fonction de l'espace cliqué.
                */
            blit(fond[numFond],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            masked_blit(bouton[numBouton],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
            rest(50);
            if((mouse_b & 1) && mouse_x>181 && mouse_x<433 && mouse_y>100 && mouse_y<122 || (mouse_b & 1) && mouse_x>235 && mouse_x<394 && mouse_y>136 && mouse_y<264){
                page++;
                numBouton++;
                nbrJoueurs=2;
            }
            else if((mouse_b & 1) && mouse_x>417 && mouse_x<665 && mouse_y>322 && mouse_y<342 || (mouse_b & 1) && mouse_x>464 && mouse_x<624 && mouse_y>357 && mouse_y<486){
                page++;
                numBouton++;
                nbrJoueurs=3;
            }
            else if((mouse_b & 1) && mouse_x>713 && mouse_x<968 && mouse_y>551 && mouse_y<578 || (mouse_b & 1) && mouse_x>767 && mouse_x<929 && mouse_y>588 && mouse_y<717){
                page++;
                numBouton++;
                nbrJoueurs=4;
            }
        }
        else if(page==4){
                //4EME: MENU DE SELECTION DES JOUEURS
                /*
                    Page de personnages, c'est ici que les joueurs vont pouvoir choisir leurs perso.
                    C'est ici que nous devons intégrer le sous_programme d'initialisation des bitmaps des structures des joueurs.
                    (les joueurs peuvent prendre les mêmes personnages ce qui ne rend pas le jeu moins intéressant).
                */
            blit(fond[numFond],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            masked_blit(bouton[numBouton],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
            rest(50);
            if((mouse_b & 1) && mouse_x>151 && mouse_x<220 && mouse_y>442 && mouse_y<568){
                if(j==nbrJoueurs){
                    page++;
                    numBouton++;
                }
                else{
                    //attribuer au personnage
                    /*
                        Le type de personnage choisi est défini (1 pour guerrier, 2 pour chasseuse, 3 pour samurai (= martial hero) et 4 pour sorcier)

                    //type=1;
                    //initialisation(&type,&j,&nbrJoueurs,&joueur);
                    */
                    joueur[j].immobile=load_bitmap("Idle1.bmp",NULL);//l'image immobile du perso
                    joueur[j].sort=load_bitmap("interfaceG.bmp",NULL);//grace acette attribution il pourra accéder aux sorts propre au personnage choisi
                    joueur[j].tete=load_bitmap("tete3.bmp",NULL);//tete pour montrer le tour du joueur
                    j++;
                }
            }
            else if((mouse_b & 1) && mouse_x>435 && mouse_x<478 && mouse_y>452 && mouse_y<570 ){
                if(j==nbrJoueurs){
                    page++;
                    numBouton++;
                }
                else{
                    //attribuer au personnage
                    /*
                        comme dit précédemment pour le guerrier, ...

                    //type=2;
                    //initialisation(&type,&j,&nbrJoueurs,&joueur);
                    */
                    joueur[j].immobile=load_bitmap("IdleH.bmp",NULL);
                    joueur[j].sort=load_bitmap("interfaceC.bmp",NULL);
                    joueur[j].tete=load_bitmap("tete2.bmp",NULL);//tete pour montrer le tour du joueur
                    j++;
                }
            }
            else if((mouse_b & 1) && mouse_x>701 && mouse_x<775 && mouse_y>420 && mouse_y<567){
                if(j==nbrJoueurs){
                    page++;
                    numBouton++;
                }
                else{
                    //attribuer au personnage
                    /*
                        comme dit précédemment pour le guerrier, ...

                    //type=3;
                    //initialisation(&type,&j,&nbrJoueurs,&joueur);
                    */
                    joueur[j].immobile=load_bitmap("Idle.bmp",NULL);
                    joueur[j].sort=load_bitmap("interfaceM.bmp",NULL);
                    joueur[j].tete=load_bitmap("tete1.bmp",NULL);//tete pour montrer le tour du joueur
                    j++;
                }
            }
            else if((mouse_b & 1) && mouse_x>972 && mouse_x<1038 && mouse_y>453 && mouse_y<571){
                if(j==nbrJoueurs){
                    page++;
                    numBouton++;
                }
                else{
                    //attribuer au personnage
                    /*
                        comme dit précédemment pour le guerrier, ...

                    //type=4;
                    //initialisation(&type,&j,&nbrJoueurs,&joueur);
                    */
                    joueur[j].immobile=load_bitmap("IdleS.bmp",NULL);
                    joueur[j].sort=load_bitmap("interfaceS.bmp",NULL);
                    joueur[j].tete=load_bitmap("tete4.bmp",NULL);//tete pour montrer le tour du joueur
                    j++;
                }
            }
        }
        else{
            /*
                Met le booléen fin à 1.
                Une petite pause pour la transition .
            */
            (*nbJ)=nbrJoueurs;
            fin=1;
            rest(500);//pause avant fin du sous-programme
            return fin;
        }
        /*
        else{
            blit(fond[numFond],buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            //masked_blit(bouton,buffy,0,0,0,0,SCREEN_W,SCREEN_H);
            blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
            rest(50);
        }*/
    }
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    POSITION DES SORTS EN FONCTION DU JOUEUR ET DU SORT CHOISI ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
/*
    Position differente en fonction de la touche du clavier appuyé. Ce qui affecte le nombre de points enleves.
    Elle va permettre de dessiner des carrées/rectangles sur une bitmap qui nous permettra ensuite d'identifier si les autres joueurs
    sont sur une de ces cases vertes et enlevera des points si un autre joueur est bien sur une des cases.
    Une fois que les joueurs sur les cases ont été identifé on va pouvoir effacer le contenu de la bitmap et recommencé le processus si nécessaire.

    La premiere position: (un carré normalement, autour du joueur)
     ###
    #   #
    #   #
    #   #
     ###
    La deuxieme position: (deux traits normalement, passant par le joueur)
        #
        #
        #
     #######
        #
        #
        #
    La troisieme position: (un carré normalement, avec le joueur au milieu)
    ###
    ###
    ###
    La quatrieme position: (un cube en haut, en bas, a gauche et a droite du joueur)
        #
    #       #
        #

*/
/*/
int emplacementSort(BITMAP* analS, t_joueur joueur[4],int *tourInstant, int* nbrJoueurs){

    //BITMAP* analS;
    int j=0;

    //analS=load_bitmap("sortFond.bmp",NULL);

    install_keyboard();
    install_mouse();
    show_mouse(screen);//affichage de la souris sur l'écran

    j=(*tourInstant);

    while(!key[KEY_ESC]){

        if(key[KEY_UP]){
            //SORTE DE RECTANGLE AUTOUR DU PERSO
            rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y-16)-(32*2)),((joueur[j].x+16)+32),((joueur[j].y-16)-32),makecol(0,255,0));
            rectfill(analS,((joueur[j].x-17)-(32*2)),((joueur[j].y-16)-32),((joueur[j].x-17)-32),((joueur[j].y+16)+32),makecol(0,255,0));
            rectfill(analS,((joueur[j].x+17)+(32*2)),((joueur[j].y-16)-32),((joueur[j].x+17)+32),((joueur[j].y+16)+32),makecol(0,255,0));
            rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y+16)+(32*2)),((joueur[j].x+16)+32),((joueur[j].y+16)+32),makecol(0,255,0));
            //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);

            for(int i=0; i<nbrJoueurs; i++){
                if(i!=j){
                    if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                        joueur[i].pvPoint= joueur[i].pvPoint - 20;
                    }
                }
            }
            clear_bitmap(analS);
        }
        else if(key[KEY_LEFT]){
            //SORTE DE LIGNE PASSANT PAR PERSO
            rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
            rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*3)),makecol(0,255,0));
            //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);
            for(int i=0; i<nbrJoueurs; i++){
                if(i!=j){
                    if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                        joueur[i].pvPoint= joueur[i].pvPoint - 20;
                    }
                }
            }
            clear_bitmap(analS);
        }
        else if(key[KEY_RIGHT]){
            //CARRE AUTOUR DU PERSO
            rectfill(analS,(joueur[j].x-48),(joueur[j].y-48),(joueur[j].x+48),(joueur[j].y+48),makecol(0,255,0));
            //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);

            for(int i=0; i<nbrJoueurs; i++){
                if(i!=j){
                    if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                        joueur[i].pvPoint= joueur[i].pvPoint - 25;
                    }
                }
            }
            clear_bitmap(analS);
        }
        else if(key[KEY_DOWN]){
            //ZONES AUTOUR DU PERSO
            rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y-16)-(32*2)),makecol(0,255,0));
            rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x-16)-(32*2)),(joueur[j].y+16),makecol(0,255,0));
            rectfill(analS,((joueur[j].x+16)+(32*2)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
            rectfill(analS,(joueur[j].x-16),((joueur[j].y+16)+(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*2)),makecol(0,255,0));
            //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);

            for(int i=0; i<nbrJoueurs; i++){
                if(i!=j){
                    if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                        joueur[i].pvPoint= joueur[i].pvPoint - 30;
                    }
                }
            }
            clear_bitmap(analS);
        }
    }
}
/*/
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    MAIN    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
int main()
{
    //Declaration des bitmaps et des variables
    int a=0,i=0,j=0,x=304,y=432,X=0,Y=0;
    int cadreA=0, cadreB=0, cadreC=0,cadreD=0;
    int finMenu=0;
    int interface=0;
    int numBouton=0;
    int click=0;
    int exit=0;
    char nomfichier[50]={0};
    t_joueur joueur[4];
    int nbrJoueurs=0;

    BITMAP* fond;//premier fond
    BITMAP* fond2;//deuxieme fond
    BITMAP* perso;
    BITMAP* buffy;//buffer
    BITMAP* cloud;
    BITMAP* cloud2;
    BITMAP* objet;
    BITMAP* finJeu;
    BITMAP* bouton[3];
    BITMAP* analS;

    init_ALLEG();//initialisation

    //initialisation des bitmaps
    //fond=load_bitmap("dep2.bmp",NULL);
    fond=load_bitmap("quadrille.bmp",NULL);
    fond2=load_bitmap("blu.bmp",NULL);
    cloud=load_bitmap("cloud3.bmp",NULL);
    cloud2=load_bitmap("cloud5.bmp",NULL);
    objet=load_bitmap("MapInfoObjet.bmp",NULL);
    analS=load_bitmap("sortFond.bmp",NULL);
    finJeu=load_bitmap("page4.bmp",NULL);

    for(numBouton=0;numBouton<NBRINTER;numBouton++){
        sprintf(nomfichier,"interface%d.bmp",numBouton);
        bouton[numBouton]=load_bitmap(nomfichier,NULL);
    }

    //personnage
    perso=load_bitmap("Idle.bmp",NULL);
    buffy=create_bitmap(SCREEN_W,SCREEN_H);

    //installation du clavier et de la souris
    install_keyboard();
    install_mouse();
    show_mouse(screen);//affichage de la souris sur l'écran

    //appel du debut
    finMenu=debut(joueur,&nbrJoueurs);

    //initialisation pour la fonctionnalité du jeu
    joueur[0].x=304;
    joueur[0].y=432;
    joueur[1].x=432;
    joueur[1].y=560;
    joueur[2].x=657;
    joueur[2].y=592;
    joueur[4].x=912;
    joueur[4].y=430;

    for(int attPoints=0; attPoints<nbrJoueurs; attPoints++){
        joueur[attPoints].pvPoint=100;
    }

    cadreA=joueur[j].x-(16+(32*3));
    cadreB=joueur[j].x+(16+(32*3));
    cadreC=joueur[j].y-(16+(32*3));
    cadreD=joueur[j].y+(16+(32*3));

    //debut programme principal
    while(!key[KEY_ESC]){
            if(!((mouse_b & 1) && mouse_x>=0 && mouse_x<=SCREEN_W && mouse_y>=0 && mouse_y<=SCREEN_H && mouse_x>=1051 && mouse_x<=1147 && mouse_y>=675 && mouse_y<=713)){
                //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ICI IL BOUGE  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
                if(finMenu==1 && (mouse_b & 1) && mouse_x>=0 && mouse_x<=SCREEN_W && mouse_y>=0 && mouse_y<=SCREEN_H && mouse_x>=cadreA && mouse_x<=cadreB && mouse_y>=cadreC && mouse_y<=cadreD && (getpixel(fond2,mouse_x,mouse_y)==makecol(255,255,255))){
                    //ajustement des variables
                    joueur[j].x=mouse_x;
                    joueur[j].y=mouse_y;

                    cadreA=joueur[j].x-(16+(32*3));
                    cadreB=joueur[j].x+(16+(32*3));
                    cadreC=joueur[j].y-(16+(32*3));
                    cadreD=joueur[j].y+(16+(32*3));
                    /*
                        Les conditions if et else servent a faire en sorte qu'on ai les bons affichage au bons moments
                    */
                    if((getpixel(fond2,joueur[j].x,joueur[j].y-32)==makecol(0,0,255))){
                        //ajustement de l'affichage
                        recentre(&joueur[j].x,&joueur[j].y);//recentre au milieu de la case
                        masked_blit(cloud,buffy,0,0,0,0,cloud->w,cloud->h);
                        masked_blit(fond,buffy,0,0,0,0,fond->w,fond->h);
                        rect(buffy,cadreA,cadreC,cadreB,cadreD,makecol(255,242,0));
                        masked_blit(objet,buffy,0,0,0,0,objet->w,objet->h);
                        //la boucle suivante nous permet d'avoir tout les perso qui s'affiche mais seulemnt un personnage qui bouge a sont tour
                        for(i=0; i<nbrJoueurs; i++){
                            if(i!=j){
                                 masked_blit(joueur[i].immobile,buffy,0,0,(joueur[i].x-((joueur[i].immobile->w)/2)),(joueur[i].y-(((joueur[i].immobile->h)+40)/2)), joueur[i].immobile->w,joueur[i].immobile->h);
                            }
                            masked_blit(joueur[j].immobile,buffy,0,0,(joueur[j].x-((joueur[j].immobile->w)/2)),(joueur[j].y-(((joueur[j].immobile->h)+40)/2)), joueur[j].immobile->w,joueur[j].immobile->h);
                        }
                        //decor
                        masked_blit(cloud2,buffy,0,0,0,0,cloud2->w,cloud2->h);
                        masked_blit(bouton[0],buffy,0,0,0,0,bouton[0]->w,bouton[0]->h);
                        masked_blit(bouton[1],buffy,0,0,0,0,bouton[1]->w,bouton[1]->h);
                        masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                        //si la souris est sur le "livre" en bas a gauche alors l'interface, les points de pvs et coordonnees et options de sorts sont affichés
                        if(mouse_x>=25 && mouse_x<=135 && mouse_y>=667 && mouse_y<=775){
                                masked_blit(joueur[j].sort,buffy,0,0,20,256, joueur[j].sort->w,joueur[j].sort->h);
                                textprintf_ex(buffy,font,71,340,makecol(0,255,0),-1,"PV: %d pts",joueur[j].pvPoint);
                                textprintf_ex(buffy,font,71,370,makecol(0,255,0),-1,"x: %d / y: %d",((joueur[j].x+16)/32),((joueur[j].y+16)/32));
                                masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                                if(key[KEY_UP]){
                                    //SORTE DE RECTANGLE AUTOUR DU PERSO
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y-16)-(32*2)),((joueur[j].x+16)+32),((joueur[j].y-16)-32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-17)-(32*2)),((joueur[j].y-16)-32),((joueur[j].x-17)-32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+17)+(32*2)),((joueur[j].y-16)-32),((joueur[j].x+17)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y+16)+(32*2)),((joueur[j].x+16)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }

                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_LEFT]){
                                    //SORTE DE LIGNE PASSANT PAR PERSO
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*3)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }

                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_RIGHT]){
                                    //CARRE AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-48),(joueur[j].y-48),(joueur[j].x+48),(joueur[j].y+48),makecol(255,0,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 25;
                                            }
                                        }
                                    }

                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_DOWN]){
                                    //ZONES AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y-16)-(32*2)),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x-16)-(32*2)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+16)+(32*2)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y+16)+(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*2)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 30;
                                            }
                                        }
                                    }

                                    clear_bitmap(analS);
                                }
                        }
                        masked_blit(bouton[0],buffy,0,0,0,0,bouton[0]->w,bouton[0]->h);
                        blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
                        rest(100);
                    }
                    else{
                        //ajustement de l'affichage
                        recentre(&joueur[j].x,&joueur[j].y);//recentre au milieu de la case
                        masked_blit(cloud,buffy,0,0,0,0,cloud->w,cloud->h);
                        masked_blit(fond,buffy,0,0,0,0,fond->w,fond->h);
                        //la boucle suivante nous permet d'avoir tout les perso qui s'affiche mais seulemnt un personnage qui bouge a sont tour
                        for(i=0; i<nbrJoueurs; i++){
                            if(i!=j){
                                 masked_blit(joueur[i].immobile,buffy,0,0,(joueur[i].x-((joueur[i].immobile->w)/2)),(joueur[i].y-(((joueur[i].immobile->h)+40)/2)), joueur[i].immobile->w,joueur[i].immobile->h);
                            }
                            masked_blit(joueur[j].immobile,buffy,0,0,(joueur[j].x-((joueur[j].immobile->w)/2)),(joueur[j].y-(((joueur[j].immobile->h)+40)/2)), joueur[j].immobile->w,joueur[j].immobile->h);
                        }
                        rect(buffy,cadreA,cadreC,cadreB,cadreD,makecol(255,242,0));
                        masked_blit(objet,buffy,0,0,0,0,objet->w,objet->h);
                        masked_blit(cloud2,buffy,0,0,0,0,cloud2->w,cloud2->h);
                        masked_blit(bouton[0],buffy,0,0,0,0,bouton[0]->w,bouton[0]->h);
                        masked_blit(bouton[1],buffy,0,0,0,0,bouton[1]->w,bouton[1]->h);
                        masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                        //si la souris est sur le "livre" en bas a gauche alors l'interface, les points de pvs et coordonnees et options de sorts sont affichés
                        if(mouse_x>=25 && mouse_x<=135 && mouse_y>=667 && mouse_y<=775){
                                masked_blit(joueur[j].sort,buffy,0,0,20,256, joueur[j].sort->w,joueur[j].sort->h);
                                textprintf_ex(buffy,font,71,340,makecol(0,255,0),-1,"PV: %d pts",joueur[j].pvPoint);
                                textprintf_ex(buffy,font,71,370,makecol(0,255,0),-1,"x: %d / y: %d",((joueur[j].x+16)/32),((joueur[j].y+16)/32));
                                masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                                //partie suivante devrait etre remplacé par "emplacementSort()"
                                if(key[KEY_UP]){
                                    //SORTE DE RECTANGLE AUTOUR DU PERSO
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y-16)-(32*2)),((joueur[j].x+16)+32),((joueur[j].y-16)-32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-17)-(32*2)),((joueur[j].y-16)-32),((joueur[j].x-17)-32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+17)+(32*2)),((joueur[j].y-16)-32),((joueur[j].x+17)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y+16)+(32*2)),((joueur[j].x+16)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_LEFT]){
                                    //SORTE DE LIGNE PASSANT PAR PERSO
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*3)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_RIGHT]){
                                    //CARRE AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-48),(joueur[j].y-48),(joueur[j].x+48),(joueur[j].y+48),makecol(255,0,0));
                                    //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);

                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 25;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_DOWN]){
                                    //ZONES AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y-16)-(32*2)),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x-16)-(32*2)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+16)+(32*2)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y+16)+(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*2)),makecol(0,255,0));
                                    //blit(buffy,screen,0,0,0,0,SCREEN_W,SCREEN_H);

                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 30;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                        }
                        blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
                        rest(100);
                    }
                }
                //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BOUGE  PAS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
                    if((getpixel(fond2,joueur[j].x,joueur[j].y-32)==makecol(0,0,255))){
                        masked_blit(cloud,buffy,0,0,0,0,cloud->w,cloud->h);
                        masked_blit(fond,buffy,0,0,0,0,fond->w,fond->h);
                        rect(buffy,cadreA,cadreC,cadreB,cadreD,makecol(255,242,0));
                        masked_blit(objet,buffy,0,0,0,0,fond->w,fond->h);
                        for(i=0; i<nbrJoueurs; i++){
                            if(i!=j){
                                 masked_blit(joueur[i].immobile,buffy,0,0,(joueur[i].x-((joueur[i].immobile->w)/2)),(joueur[i].y-(((joueur[i].immobile->h)+40)/2)), joueur[i].immobile->w,joueur[i].immobile->h);
                            }
                            masked_blit(joueur[j].immobile,buffy,0,0,(joueur[j].x-((joueur[j].immobile->w)/2)),(joueur[j].y-(((joueur[j].immobile->h)+40)/2)), joueur[j].immobile->w,joueur[j].immobile->h);
                        }
                        masked_blit(cloud2,buffy,0,0,0,0,cloud2->w,cloud2->h);
                        masked_blit(bouton[0],buffy,0,0,0,0,bouton[0]->w,bouton[0]->h);
                        masked_blit(bouton[1],buffy,0,0,0,0,bouton[1]->w,bouton[1]->h);
                        masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                        //si la souris est sur le "livre" en bas a gauche alors l'interface, les points de pvs et coordonnees et options de sorts sont affichés
                        if(mouse_x>=25 && mouse_x<=135 && mouse_y>=667 && mouse_y<=775){
                                masked_blit(joueur[j].sort,buffy,0,0,20,256, joueur[j].sort->w,joueur[j].sort->h);
                                textprintf_ex(buffy,font,71,340,makecol(0,255,0),-1,"PV: %d pts",joueur[j].pvPoint);
                                textprintf_ex(buffy,font,71,370,makecol(0,255,0),-1,"x: %d / y: %d",((joueur[j].x+16)/32),((joueur[j].y+16)/32));
                                masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                                //partie suivante devrait etre remplacé par "emplacementSort()"
                                if(key[KEY_UP]){
                                    //SORTE DE RECTANGLE AUTOUR DU PERSO
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y-16)-(32*2)),((joueur[j].x+16)+32),((joueur[j].y-16)-32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-17)-(32*2)),((joueur[j].y-16)-32),((joueur[j].x-17)-32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+17)+(32*2)),((joueur[j].y-16)-32),((joueur[j].x+17)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y+16)+(32*2)),((joueur[j].x+16)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_LEFT]){
                                    //SORTE DE LIGNE PASSANT PAR PERSO
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*3)),makecol(0,255,0));

                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_RIGHT]){
                                    //CARRE AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-48),(joueur[j].y-48),(joueur[j].x+48),(joueur[j].y+48),makecol(255,0,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 25;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_DOWN]){
                                    //ZONES AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y-16)-(32*2)),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x-16)-(32*2)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+16)+(32*2)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y+16)+(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*2)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 30;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                        }
                        blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
                    }
                    else{
                        //decor
                        masked_blit(cloud,buffy,0,0,0,0,cloud->w,cloud->h);
                        masked_blit(fond,buffy,0,0,0,0,fond->w,fond->h);
                        //la boucle suivante nous permet d'avoir tout les perso qui s'affiche mais seulemnt un personnage qui bouge a sont tour
                        for(i=0; i<nbrJoueurs; i++){
                            if(i!=j){
                                 masked_blit(joueur[i].immobile,buffy,0,0,(joueur[i].x-((joueur[i].immobile->w)/2)),(joueur[i].y-(((joueur[i].immobile->h)+40)/2)), joueur[i].immobile->w,joueur[i].immobile->h);
                            }
                            masked_blit(joueur[j].immobile,buffy,0,0,(joueur[j].x-((joueur[j].immobile->w)/2)),(joueur[j].y-(((joueur[j].immobile->h)+40)/2)), joueur[j].immobile->w,joueur[j].immobile->h);
                        }
                        rect(buffy,cadreA,cadreC,cadreB,cadreD,makecol(255,242,0));//zone de déplacement possible
                        //decor
                        masked_blit(objet,buffy,0,0,0,0,fond->w,fond->h);
                        masked_blit(cloud2,buffy,0,0,0,0,cloud2->w,cloud2->h);
                        masked_blit(bouton[0],buffy,0,0,0,0,bouton[0]->w,bouton[0]->h);
                        masked_blit(bouton[1],buffy,0,0,0,0,bouton[1]->w,bouton[1]->h);
                        masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                        //si la souris est sur le "livre" en bas a gauche alors l'interface, les points de pvs et coordonnees et options de sorts sont affichés
                        if(mouse_x>=25 && mouse_x<=135 && mouse_y>=667 && mouse_y<=775){
                                masked_blit(joueur[j].sort,buffy,0,0,20,256, joueur[j].sort->w,joueur[j].sort->h);//affichage de l'interface/infos des joueurs
                                textprintf_ex(buffy,font,71,340,makecol(0,255,0),-1,"PV: %d pts",joueur[j].pvPoint);//affiche les points de pv du joueur
                                textprintf_ex(buffy,font,71,370,makecol(0,255,0),-1,"x: %d / y: %d",((joueur[j].x+16)/32),((joueur[j].y+16)/32));//affiche les coordonnees du joueur
                                masked_blit(joueur[j].tete,buffy,0,0,560,19, joueur[j].tete->w,joueur[j].tete->h);
                                //PARTIE SUIVANTE REMPLACE LE SOUS PROGRAMME DE SORT QUI NE FONCTIONNE PAS
                                if(key[KEY_UP]){
                                    //SORTE DE RECTANGLE AUTOUR DU PERSO
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y-16)-(32*2)),((joueur[j].x+16)+32),((joueur[j].y-16)-32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-17)-(32*2)),((joueur[j].y-16)-32),((joueur[j].x-17)-32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+17)+(32*2)),((joueur[j].y-16)-32),((joueur[j].x+17)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-32),((joueur[j].y+16)+(32*2)),((joueur[j].x+16)+32),((joueur[j].y+16)+32),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_LEFT]){
                                    //SORTE DE LIGNE PASSANT PAR PERSO
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*3)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 20;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_RIGHT]){
                                    //CARRE AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-48),(joueur[j].y-48),(joueur[j].x+48),(joueur[j].y+48),makecol(255,0,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 25;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                                else if(key[KEY_DOWN]){
                                    //ZONES AUTOUR DU PERSO
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y-16)-(32*3)),(joueur[j].x+16),((joueur[j].y-16)-(32*2)),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x-16)-(32*3)),(joueur[j].y-16),((joueur[j].x-16)-(32*2)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,((joueur[j].x+16)+(32*2)),(joueur[j].y-16),((joueur[j].x+16)+(32*3)),(joueur[j].y+16),makecol(0,255,0));
                                    rectfill(analS,(joueur[j].x-16),((joueur[j].y+16)+(32*3)),(joueur[j].x+16),((joueur[j].y+16)+(32*2)),makecol(0,255,0));
                                    for(int i=0; i<nbrJoueurs; i++){
                                        if(i!=j){
                                            if(getpixel(analS,joueur[i].x,joueur[i].y)==makecol(0,255,0)){
                                                joueur[i].pvPoint= joueur[i].pvPoint - 30;
                                            }
                                        }
                                    }
                                    clear_bitmap(analS);
                                }
                        }
                        //affichage
                        blit(buffy,screen,0,0,0,0,buffy->w,buffy->h);
                    }

            }
            else if(((mouse_b & 1) && mouse_x>=0 && mouse_x<=SCREEN_W && mouse_y>=0 && mouse_y<=SCREEN_H && mouse_x>=1051 && mouse_x<=1147 && mouse_y>=675 && mouse_y<=713)){
                //change le perso si le bouton "joueur suivant" est appuyé
                if(j==nbrJoueurs-1){
                    j=0;
                }
                else{
                    j++;
                }
            }
            /*/QUITTER (a optimiser)
            else if(((mouse_b & 1) && mouse_x>=0 && mouse_x<=SCREEN_W && mouse_y>=0 && mouse_y<=SCREEN_H && mouse_x>=1065 && mouse_x<=1165 && mouse_y>=724 && mouse_y<=776)){
                    masked_blit(finJeu,screen,0,0,0,0,SCREEN_W,SCREEN_H);
            }
            /*/
    }
    allegro_exit();
    destroy_bitmap(buffy);
    destroy_bitmap(fond);
    destroy_bitmap(fond2);

    return 0;
}END_OF_MAIN();
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
